diff --git a/core/fpdftext/cpdf_textpage.cpp b/core/fpdftext/cpdf_textpage.cpp
index 5690698..4d7c48a 100644
--- a/core/fpdftext/cpdf_textpage.cpp
+++ b/core/fpdftext/cpdf_textpage.cpp
@@ -1464,3 +1464,32 @@ Optional<PAGECHAR_INFO> CPDF_TextPage::GenerateCharInfo(wchar_t unicode) {
                                  info.m_Origin.x, info.m_Origin.y);
   return info;
 }
+
+WideString CPDF_TextPage::GetTextObjectText(CPDF_TextObject* pTextObj)
+{
+  if (!m_bIsParsed)
+    return WideString();
+
+  float posy = 0;
+  bool IsContainPreChar = false;
+  bool IsAddLineFeed = false;
+  WideString strText;
+  for (const auto& charinfo : m_CharList) {
+    if (charinfo.m_pTextObj == pTextObj) {
+      IsContainPreChar = true;
+      IsAddLineFeed = false;
+      if (charinfo.m_Unicode)
+        strText += charinfo.m_Unicode;
+    } else if (charinfo.m_Unicode == 32) {
+      if (IsContainPreChar && charinfo.m_Unicode) {
+        strText += charinfo.m_Unicode;
+        IsContainPreChar = false;
+        IsAddLineFeed = false;
+      }
+    } else {
+      IsContainPreChar = false;
+      IsAddLineFeed = true;
+    }
+  }
+  return strText;
+}
diff --git a/core/fpdftext/cpdf_textpage.h b/core/fpdftext/cpdf_textpage.h
index 43a0312..7d5d5ec 100644
--- a/core/fpdftext/cpdf_textpage.h
+++ b/core/fpdftext/cpdf_textpage.h
@@ -105,6 +105,8 @@ class CPDF_TextPage {
   WideString GetPageText(int start, int count) const;
   WideString GetAllPageText() const { return GetPageText(0, CountChars()); }
 
+  WideString GetTextObjectText(CPDF_TextObject* pTextObj);
+
   int CountRects(int start, int nCount);
   bool GetRect(int rectIndex, CFX_FloatRect* pRect) const;
 
diff --git a/fpdfsdk/cpdfsdk_helpers.h b/fpdfsdk/cpdfsdk_helpers.h
index d93ecfc..c700592 100644
--- a/fpdfsdk/cpdfsdk_helpers.h
+++ b/fpdfsdk/cpdfsdk_helpers.h
@@ -40,7 +40,8 @@ class CPDF_TextPage;
 class CPDF_TextPageFind;
 class IPDFSDK_PauseAdapter;
 class FX_PATHPOINT;
-
+class CPDF_TextObject;
+class CPDF_FormObject;
 #ifdef PDF_ENABLE_XFA
 class CPDFXFA_Context;
 class CPDFXFA_Page;
@@ -204,6 +205,16 @@ inline CPDF_TextPageFind* CPDFTextPageFindFromFPDFSchHandle(
   return reinterpret_cast<CPDF_TextPageFind*>(handle);
 }
 
+inline CPDF_TextObject* CPDFTextObjectFromFPDFPageObject(
+    FPDF_PAGEOBJECT page_object) {
+  return reinterpret_cast<CPDF_TextObject*>(page_object);
+}
+
+inline CPDF_FormObject* CPDFFormObjectFromFPDFPageObject(
+    FPDF_PAGEOBJECT page_object) {
+  return reinterpret_cast<CPDF_FormObject*>(page_object);
+}
+
 ByteString CFXByteStringFromFPDFWideString(FPDF_WIDESTRING wide_string);
 
 #ifdef PDF_ENABLE_XFA
diff --git a/fpdfsdk/fpdf_editimg.cpp b/fpdfsdk/fpdf_editimg.cpp
index fed1581..968b84a 100644
--- a/fpdfsdk/fpdf_editimg.cpp
+++ b/fpdfsdk/fpdf_editimg.cpp
@@ -186,6 +186,26 @@ FPDFImageObj_GetBitmap(FPDF_PAGEOBJECT image_object) {
   return FPDFBitmapFromCFXDIBitmap(pBitmap.Leak());
 }
 
+FPDF_EXPORT FPDF_BITMAP FPDF_CALLCONV
+FPDFImageObj_GetBitmapBgra(FPDF_PAGEOBJECT image_object) {
+  CPDF_PageObject* pObj = CPDFPageObjectFromFPDFPageObject(image_object);
+  if (!pObj || !pObj->IsImage())
+    return nullptr;
+
+  RetainPtr<CPDF_Image> pImg = pObj->AsImage()->GetImage();
+  if (!pImg)
+    return nullptr;
+
+  RetainPtr<CFX_DIBSource> pSource = pImg->LoadDIBSource();
+  if (!pSource)
+    return nullptr;
+
+  RetainPtr<CFX_DIBitmap> pBitmap;
+  pBitmap = pSource->CloneConvert(FXDIB_Argb);
+
+  return FPDFBitmapFromCFXDIBitmap(pBitmap.Leak());
+}
+
 FPDF_EXPORT unsigned long FPDF_CALLCONV
 FPDFImageObj_GetImageDataDecoded(FPDF_PAGEOBJECT image_object,
                                  void* buffer,
diff --git a/fpdfsdk/fpdf_editpage.cpp b/fpdfsdk/fpdf_editpage.cpp
index ec29891..a52e1a9 100644
--- a/fpdfsdk/fpdf_editpage.cpp
+++ b/fpdfsdk/fpdf_editpage.cpp
@@ -12,12 +12,14 @@
 #include <vector>
 
 #include "core/fpdfapi/edit/cpdf_pagecontentgenerator.h"
+#include "core/fpdfapi/font/cpdf_font.h"
 #include "core/fpdfapi/page/cpdf_form.h"
 #include "core/fpdfapi/page/cpdf_formobject.h"
 #include "core/fpdfapi/page/cpdf_imageobject.h"
 #include "core/fpdfapi/page/cpdf_page.h"
 #include "core/fpdfapi/page/cpdf_pageobject.h"
 #include "core/fpdfapi/page/cpdf_pathobject.h"
+#include "core/fpdfapi/page/cpdf_textobject.h"
 #include "core/fpdfapi/page/cpdf_shadingobject.h"
 #include "core/fpdfapi/parser/cpdf_array.h"
 #include "core/fpdfapi/parser/cpdf_document.h"
@@ -25,6 +27,7 @@
 #include "core/fpdfapi/parser/cpdf_string.h"
 #include "core/fpdfdoc/cpdf_annot.h"
 #include "core/fpdfdoc/cpdf_annotlist.h"
+#include "core/fpdftext/cpdf_textpage.h"
 #include "fpdfsdk/cpdfsdk_helpers.h"
 #include "public/fpdf_formfill.h"
 #include "third_party/base/logging.h"
@@ -624,3 +627,245 @@ FPDFPageObj_SetLineCap(FPDF_PAGEOBJECT page_object, int line_cap) {
   pPageObj->SetDirty(true);
   return true;
 }
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_CountChars(FPDF_PAGEOBJECT text_object)
+{
+  if (!text_object)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  return pTxtObj->CountChars();
+}
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetFontSize(FPDF_PAGEOBJECT text_object)
+{
+  if (!text_object)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  return pTxtObj->GetFontSize();
+}
+
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFTextObj_GetMatrix(FPDF_PAGEOBJECT text_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f)
+{
+  if (!text_object || !a || !b || !c || !d || !e || !f)
+    return;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  const CFX_Matrix& matrix = pTxtObj->GetTextMatrix();
+  *a = matrix.a;
+  *b = matrix.b;
+  *c = matrix.c;
+  *d = matrix.d;
+  *e = matrix.e;
+  *f = matrix.f;
+}
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetUnicode(FPDF_PAGEOBJECT text_object, int index)
+{
+  if (!text_object || index < 0)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  if (index > pTxtObj->CountChars())
+    return 0;
+
+  CPDF_TextObjectItem info;
+  pTxtObj->GetCharInfo(index, &info);
+  return info.m_CharCode;
+}
+
+FPDF_EXPORT int FPDF_CALLCONV FPDFTextObj_GetText(FPDF_PAGEOBJECT text_object,
+                                                  int char_start,
+                                                  int char_count,
+                                                  unsigned short* result) {
+  if (!text_object || char_start < 0 || char_count < 0 || !result)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  int char_available = pTxtObj->CountChars() - char_start;
+  if (char_available <= 0)
+    return 0;
+
+  char_count = std::min(char_count, char_available);
+  if (char_count == 0) {
+    // Writing out "", which has a character count of 1 due to the NUL.
+    *result = '\0';
+    return 1;
+  }
+
+  CPDF_Font* pFont = pTxtObj->GetFont();
+  WideString str;
+  for (uint32_t charcode : pTxtObj->GetCharCodes()) {
+    if (charcode != CPDF_Font::kInvalidCharCode)
+      str += pFont->UnicodeFromCharCode(charcode);
+  }
+
+  // UFT16LE_Encode doesn't handle surrogate pairs properly, so it is expected
+  // the number of items to stay the same.
+  ByteString byte_str = str.UTF16LE_Encode();
+  size_t byte_str_len = byte_str.GetLength();
+  int ret_count = byte_str_len / sizeof(unsigned short);
+
+  ASSERT(ret_count <= char_count + 1);  // +1 to account for the NUL terminator.
+  memcpy(result, byte_str.GetBuffer(byte_str_len).data(), byte_str_len);
+  return ret_count;
+}
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetTextProcessed(FPDF_PAGEOBJECT text_object,
+                             FPDF_TEXTPAGE page,
+                             int char_start,
+                             int char_count,
+                             unsigned short* result)
+{
+  if (!page || !text_object || char_start < 0 || char_count < 0 || !result)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  CPDF_TextPage* textpage = CPDFTextPageFromFPDFTextPage(page);
+  int char_available = textpage->CountChars() - char_start;
+  if (char_available <= 0)
+    return 0;
+
+  char_count = std::min(char_count, char_available);
+  if (char_count == 0) {
+    // Writing out "", which has a character count of 1 due to the NUL.
+    *result = '\0';
+    return 1;
+  }
+
+  WideString str = textpage->GetTextObjectText(pTxtObj);
+
+  if (str.GetLength() > static_cast<size_t>(char_count))
+    str = str.Left(static_cast<size_t>(char_count));
+
+  // UFT16LE_Encode doesn't handle surrogate pairs properly, so it is expected
+  // the number of items to stay the same.
+  ByteString byte_str = str.UTF16LE_Encode();
+  size_t byte_str_len = byte_str.GetLength();
+  constexpr size_t kBytesPerCharacter = sizeof(unsigned short);
+  int ret_count = byte_str_len / kBytesPerCharacter;
+
+  ASSERT(ret_count <= char_count + 1);  // +1 to account for the NUL terminator.
+  memcpy(result, byte_str.GetBuffer(byte_str_len).data(), byte_str_len);
+  return ret_count;
+}
+
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFTextObj_GetColor(FPDF_PAGEOBJECT text_object,
+                     unsigned int* R,
+                     unsigned int* G,
+                     unsigned int* B,
+                     unsigned int* A)
+{
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  if (!pTxtObj || !R || !G || !B || !A)
+    return false;
+
+  bool bFill = false;
+  bool bStroke = false;
+  CPDF_Font* pFont = pTxtObj->m_TextState.GetFont();
+  const TextRenderingMode text_render_mode = pTxtObj->m_TextState.GetTextMode();
+  switch (text_render_mode)
+  {
+    case TextRenderingMode::MODE_FILL:
+    case TextRenderingMode::MODE_FILL_CLIP:
+      bFill = true;
+      break;
+    case TextRenderingMode::MODE_STROKE:
+    case TextRenderingMode::MODE_STROKE_CLIP:
+      if (pFont->GetFace())
+        bStroke = true;
+      else
+        bFill = true;
+      break;
+    case TextRenderingMode::MODE_FILL_STROKE:
+    case TextRenderingMode::MODE_FILL_STROKE_CLIP:
+      bFill = true;
+      if (pFont->GetFace())
+        bStroke = true;
+      break;
+    case TextRenderingMode::MODE_INVISIBLE:
+    case TextRenderingMode::MODE_CLIP:
+      return false;
+  }
+
+  const CPDF_Color* pColor = bStroke ? pTxtObj->m_ColorState.GetStrokeColor() : pTxtObj->m_ColorState.GetFillColor();
+  if (pColor == nullptr)
+    return false;
+
+  int r, g, b;
+  pColor->GetRGB(&r, &g, &b);
+  *R = r;
+  *G = g;
+  *B = b;
+  *A = static_cast<unsigned int>(
+      (pTxtObj->m_GeneralState.GetStrokeAlpha() * 255.f) + 0.5f);
+
+  return true;
+}
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFFormObj_CountSubObjects(FPDF_PAGEOBJECT form_object)
+{
+  CPDF_FormObject* pFrmObj = CPDFFormObjectFromFPDFPageObject(form_object);
+  if (pFrmObj)
+  {
+    const CPDF_PageObjectList* pObjectList = pFrmObj->form()->GetPageObjectList();
+    if (pObjectList)
+        return pObjectList->size();
+  }
+
+  return 0;
+}
+
+FPDF_EXPORT FPDF_PAGEOBJECT FPDF_CALLCONV
+FPDFFormObj_GetSubObject(FPDF_PAGEOBJECT form_object, int index)
+{
+  CPDF_FormObject* pFrmObj = CPDFFormObjectFromFPDFPageObject(form_object);
+  if (pFrmObj)
+  {
+    const CFX_Matrix& matrix = pFrmObj->form_matrix();
+    const CPDF_PageObjectList* pObjectList = pFrmObj->form()->GetPageObjectList();
+    if (pObjectList)
+        return FPDFPageObjectFromCPDFPageObject(pObjectList->GetPageObjectByIndex(index));
+  }
+
+  return nullptr;
+}
+
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFFormObj_GetMatrix(FPDF_PAGEOBJECT form_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f)
+{
+  if (!form_object || !a || !b || !c || !d || !e || !f)
+    return;
+
+  CPDF_FormObject* pFrmObj = CPDFFormObjectFromFPDFPageObject(form_object);
+  if (pFrmObj)
+  {
+    const CFX_Matrix& matrix = pFrmObj->form_matrix();
+    *a = matrix.a;
+    *b = matrix.b;
+    *c = matrix.c;
+    *d = matrix.d;
+    *e = matrix.e;
+    *f = matrix.f;
+  }
+}
diff --git a/fpdfsdk/fpdf_editpath.cpp b/fpdfsdk/fpdf_editpath.cpp
index aca2beb..017dbcd 100644
--- a/fpdfsdk/fpdf_editpath.cpp
+++ b/fpdfsdk/fpdf_editpath.cpp
@@ -117,6 +117,16 @@ FPDFPath_SetStrokeWidth(FPDF_PAGEOBJECT path, float width) {
   return true;
 }
 
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetStrokeWidth(FPDF_PAGEOBJECT path, float* width) {
+  auto* pPathObj = CPDFPathObjectFromFPDFPageObject(path);
+  if (!pPathObj || !width)
+    return false;
+
+  *width = pPathObj->m_GraphState.GetLineWidth();
+  return true;
+}
+
 FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_SetFillColor(FPDF_PAGEOBJECT path,
                                                           unsigned int R,
                                                           unsigned int G,
@@ -235,6 +245,25 @@ FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_SetDrawMode(FPDF_PAGEOBJECT path,
   return true;
 }
 
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_GetDrawMode(FPDF_PAGEOBJECT path,
+                                                         int* fillmode,
+                                                         FPDF_BOOL* stroke)
+{
+  auto* pPathObj = CPDFPathObjectFromFPDFPageObject(path);
+  if (!pPathObj || !fillmode || !stroke)
+    return false;
+
+  if (pPathObj->m_FillType == FXFILL_ALTERNATE)
+    *fillmode = FPDF_FILLMODE_ALTERNATE;
+  else if (pPathObj->m_FillType == FXFILL_WINDING)
+    *fillmode = FPDF_FILLMODE_WINDING;
+  else
+    *fillmode = 0; // no fill
+
+  *stroke = pPathObj->m_bStroke;
+  return true;
+}
+
 FPDF_EXPORT void FPDF_CALLCONV FPDFPath_SetLineJoin(FPDF_PAGEOBJECT path,
                                                     int line_join) {
   if (!path)
@@ -268,6 +297,30 @@ FPDF_EXPORT void FPDF_CALLCONV FPDFPath_SetLineCap(FPDF_PAGEOBJECT path,
 }
 
 FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetMatrix(FPDF_PAGEOBJECT path_object,
+                   double* a,
+                   double* b,
+                   double* c,
+                   double* d,
+                   double* e,
+                   double* f)
+{
+  if (!path_object || !a || !b || !c || !d || !e || !f)
+    return false;
+
+  CPDF_PathObject* pPathObj = CPDFPathObjectFromFPDFPageObject(path_object);
+  const CFX_Matrix& pMatrix = pPathObj->m_Matrix;
+  *a = pMatrix.a;
+  *b = pMatrix.b;
+  *c = pMatrix.c;
+  *d = pMatrix.d;
+  *e = pMatrix.e;
+  *f = pMatrix.f;
+
+  return true;
+}
+
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
 FPDFPathSegment_GetPoint(FPDF_PATHSEGMENT segment, float* x, float* y) {
   auto* pPathPoint = FXPathPointFromFPDFPathSegment(segment);
   if (!pPathPoint || !x || !y)
diff --git a/fpdfsdk/fpdf_text.cpp b/fpdfsdk/fpdf_text.cpp
index a1bbbb4..01b74c9 100644
--- a/fpdfsdk/fpdf_text.cpp
+++ b/fpdfsdk/fpdf_text.cpp
@@ -95,6 +95,28 @@ FPDF_EXPORT double FPDF_CALLCONV FPDFText_GetFontSize(FPDF_TEXTPAGE text_page,
   return charinfo.m_FontSize;
 }
 
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFText_GetMatrix(FPDF_TEXTPAGE text_page,
+                                                  int index,
+                                                  double* a,
+                                                  double* b,
+                                                  double* c,
+                                                  double* d) {
+  if (!text_page || index < 0)
+    return false;
+
+  CPDF_TextPage* textpage = CPDFTextPageFromFPDFTextPage(text_page);
+  if (index >= textpage->CountChars())
+    return false;
+
+  FPDF_CHAR_INFO charinfo;
+  textpage->GetCharInfo(index, &charinfo);
+  *a = charinfo.m_Matrix.a;
+  *b = charinfo.m_Matrix.b;
+  *c = charinfo.m_Matrix.c;
+  *d = charinfo.m_Matrix.d;
+  return true;
+}
+
 FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFText_GetCharBox(FPDF_TEXTPAGE text_page,
                                                         int index,
                                                         double* left,
diff --git a/public/fpdf_edit.h b/public/fpdf_edit.h
index c0766a3..4351649 100644
--- a/public/fpdf_edit.h
+++ b/public/fpdf_edit.h
@@ -660,6 +660,15 @@ FPDFPageObj_GetStrokeColor(FPDF_PAGEOBJECT page_object,
                            unsigned int* B,
                            unsigned int* A);
 
+// Get the stroke width of a path.
+//
+// path   - the handle to the path object.
+// width  - the width of the stroke.
+//
+// Returns TRUE on success
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetStrokeWidth(FPDF_PAGEOBJECT path, float* width);
+
 // Set the stroke width of a path.
 //
 // path   - the handle to the path object.
@@ -898,6 +907,36 @@ FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_SetDrawMode(FPDF_PAGEOBJECT path,
                                                          int fillmode,
                                                          FPDF_BOOL stroke);
 
+// Get the drawing mode of a path.
+//
+// path     - the handle to the path object.
+// fillmode - the filling mode to be set: 0 for no fill, 1 for alternate, 2 for
+// winding.
+// stroke   - a boolean specifying if the path should be stroked or not.
+//
+// Returns TRUE on success
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_GetDrawMode(FPDF_PAGEOBJECT path,
+                                                         int* fillmode,
+                                                         FPDF_BOOL* stroke);
+
+// Get the matrix of a particular text object.
+//
+// path_object - Handle of path object returned by FPDFPath_NewPathObj
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//   e            - Pointer to a double value receiving coefficient "e" of the matrix.
+//   f            - Pointer to a double value receiving coefficient "f" of the matrix.
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetMatrix(FPDF_PAGEOBJECT path_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f);
+
 // Create a new text object using one of the standard PDF fonts.
 //
 // document   - handle to the document.
@@ -971,6 +1010,125 @@ FPDFPageObj_CreateTextObj(FPDF_DOCUMENT document,
                           FPDF_FONT font,
                           float font_size);
 
+// Get the number of characters from a text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+// Return Value:
+// A character count in the text object.
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_CountChars(FPDF_PAGEOBJECT text_object);
+
+
+// Get the font size of a text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+//
+// Return Value:
+// The value of the font size
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetFontSize(FPDF_PAGEOBJECT text_object);
+
+// Get the matrix of a particular text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//   e            - Pointer to a double value receiving coefficient "e" of the matrix.
+//   f            - Pointer to a double value receiving coefficient "f" of the matrix.
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFTextObj_GetMatrix(FPDF_PAGEOBJECT text_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f);
+
+// Get the unicode of a special character in a text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+// index - The index of the character to get the unicode.
+// Return Value:
+// The unicode value.
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetUnicode(FPDF_PAGEOBJECT text_object, int index);
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetText(FPDF_PAGEOBJECT text_object,
+                    int char_start,
+                    int char_count,
+                    unsigned short* result);
+
+// Get the processed text of a text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+// Return Value:
+// The number of characters (not bytes) written in result.
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetTextProcessed(FPDF_PAGEOBJECT text_object,
+                             FPDF_TEXTPAGE page,
+                             int char_start,
+                             int char_count,
+                             unsigned short* result);
+
+// Get the stroke RGBA of a text. Range of values: 0 - 255.
+//
+// path   - the handle to the path object.
+// R      - the red component of the path stroke color.
+// G      - the green component of the path stroke color.
+// B      - the blue component of the path stroke color.
+// A      - the stroke alpha of the path.
+//
+// Returns TRUE on success.
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFTextObj_GetColor(FPDF_PAGEOBJECT text_object,
+                     unsigned int* R,
+                     unsigned int* G,
+                     unsigned int* B,
+                     unsigned int* A);
+
+// Get number of page objects inside the form object.
+//
+// form_object - Handle to a form object. Returned by FPDFPage_GetObject.
+// Return value:
+// The number of the page objects.
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFFormObj_CountSubObjects(FPDF_PAGEOBJECT form_object);
+
+// Get the page object from a form object.
+//
+// form_object - Handle to a form object. Returned by FPDFPage_GetObject.
+// index - The index of a page object.
+// Return value:
+// The handle of the page object. Null for failed.
+FPDF_EXPORT FPDF_PAGEOBJECT FPDF_CALLCONV
+FPDFFormObj_GetSubObject(FPDF_PAGEOBJECT form_object, int index);
+
+// Get the matrix of a particular form object.
+//
+// form_object - Handle of form object
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//   e            - Pointer to a double value receiving coefficient "e" of the matrix.
+//   f            - Pointer to a double value receiving coefficient "f" of the matrix.
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFFormObj_GetMatrix(FPDF_PAGEOBJECT form_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f);
+
 #ifdef __cplusplus
 }  // extern "C"
 #endif  // __cplusplus
diff --git a/public/fpdf_text.h b/public/fpdf_text.h
index 3502337..6524cd3 100644
--- a/public/fpdf_text.h
+++ b/public/fpdf_text.h
@@ -342,6 +342,26 @@ FPDF_EXPORT int FPDF_CALLCONV FPDFText_GetSchCount(FPDF_SCHHANDLE handle);
 //
 FPDF_EXPORT void FPDF_CALLCONV FPDFText_FindClose(FPDF_SCHHANDLE handle);
 
+// Get the matrix of a particular character.
+//
+// text_page - Handle to a text page information structure.
+//             Returned by FPDFText_LoadPage function.
+// index - Zero-based index of the character
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//
+// Return Value:
+//          On success, return TRUE and fill in |a|, |b|, |c|, and |d|
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFText_GetMatrix(FPDF_TEXTPAGE text_page,
+                   int index,
+                   double* a,
+                   double* b,
+                   double* c,
+                   double* d);
+
 // Function: FPDFLink_LoadWebLinks
 //          Prepare information about weblinks in a page.
 // Parameters:
diff --git a/public/fpdfview.h b/public/fpdfview.h
index 0ccd140..b451b9c 100644
--- a/public/fpdfview.h
+++ b/public/fpdfview.h
@@ -905,6 +905,9 @@ FPDF_EXPORT FPDF_BITMAP FPDF_CALLCONV FPDFBitmap_CreateEx(int width,
 //          function; see the list of such formats above.
 FPDF_EXPORT int FPDF_CALLCONV FPDFBitmap_GetFormat(FPDF_BITMAP bitmap);
 
+FPDF_EXPORT FPDF_BITMAP FPDF_CALLCONV
+FPDFImageObj_GetBitmapBgra(FPDF_PAGEOBJECT image_object);
+
 // Function: FPDFBitmap_FillRect
 //          Fill a rectangle in a bitmap.
 // Parameters:
